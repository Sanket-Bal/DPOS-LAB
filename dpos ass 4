Laboratory Assignments 4

Subject: Design Principles of Operating Systems
Subject code: CSE 3249
Assignment 4: Familiarization with Process Management in Linux 
environment.

Objective of this Assignment:
 To trace the different states of a process during its execution.
 To learn the use of different system calls such as (fork(),vfork(),wait(),exec()) for
process handling in Unix/Linux environment.

-----------------------------------------------------------------------------------------------------------------------------

1. Write a C program to create a child process using fork() system call. The child process will
print the message “Child” with its process identifier and then continue in an indefinite loop.
The parent process will print the message “Parent” with its process identifier and then
continue in an indefinite loop.
a) Run the program and trace the state of both processes.
b) Terminate the child process. Then trace the state of processes.
c) Run the program and trace the state of both processes. Terminate the parent process. Then
trace the state of processes.
d) Modify the program so that the parent process after displaying the message will wait for
child process to complete its task. Again run the program and trace the state of both
processes.
e) Terminate the child process. Then trace the state of processes.

Answer:

#include <stdio.h>
#include <unistd.h>

int main() {
    __pid_t pid = fork();

    if (pid == 0) {
        printf("Child: PID=%d, PPID=%d\n", getpid(), getppid());
        while(1);   // infinite loop
    }
    else {
        printf("Parent: PID=%d, PPID=%d\n", getpid(), getppid());
        while(1);   // infinite loop
    }
    return 0;
}




 a. command- ps -l
 b. command-kill <child_pid>
   ps -l
 c. command- kill <parent_pid>
 


d.
#include <stdio.h>
#include <unistd.h>
#include <sys/wait.h>

int main() {
    pid_t pid = fork();

    if (pid == 0) {
        printf("Child: PID=%d\n", getpid());
        while(1);
    }
    else {
        printf("Parent waiting for child...\n");
        wait(NULL);  // wait for child to finish
        printf("Parent exiting.\n");
    }
    return 0;
}


e. kill child while parents wait

-----------------------------------------------------------------------------------------------------------------------------


2. Trace the output of the following codes:

a) int main( )
 {
 if(fork()==0)
 printf("1");
 else
 printf("2");
 printf("3");
return 0;
}

Ans: 13
     23


b) int main( )
 {
 if(vfork()==0)
 {
 printf("1");
 _exit(0);
 }
 else
 printf("2");
 printf("3");
 }

Ans: 1
     23

c) int main( )
 {
 pid_t pid;
 int i=5;
 pid=fork();
 i=i+1;
 if(pid= =0)
 {
 printf("Child: %d",i);
 }
 else
 {
 wait(NULL);
 printf("Parent: %d",i);
 }
 return 0;
 }

Ans: child:6
     parent:6


d) int main( )
 {
 pid_t pid;
 int i=5;
 pid=vfork();
 i=i+1;
 if(pid==0)
 {
 printf("Child: %d",i);
 _exit(0);
 }
 else
 {
 printf("Parent: %d",i);
 }
 return 0;
 }

Ans: child:6
     parent:6 


e) int main( )
 {
 pid_t pid;
 int i=5;
 pid=fork();
 if(pid= =0)
 {
 i=i+1;
 printf("Child: %d",i);
 }
 else
 {
 wait(NULL);
 printf("Parent: %d",i);
 }
 return 0;
 }

Ans: child:6
     parent:5



f) int main( )
 { 
 pid_t pid;
 int i=5;
 pid=vfork();
 if(pid==0)
 {
 i=i+1;
 printf("Child: %d",i);
 _exit(0);
 }
 else
 {
 printf("Parent: %d",i);
 }
 return 0;
 }

Ans: child:6
     parent:6

g) int main( )
 {
 int i=5;
 if(fork( )==0)
 {
 printf("Child: %d",i);
 }
 else
 {
 printf("Parent: %d",i);
 }
 return 0;
 }
Ans: child:5
     parent:5

h) int main( )
 {
 int i=5;
 if(vfork( )==0)
 {
 printf("Child: %d",i);
 _exit(0);
 }
 else
 {
 printf("Parent: %d",i);
 }
 return 0;
 }
Ans: child:5
     parent:5

i) int main( )
 
{
 if(fork( )==0)
 
{
 printf("1");
 
}
 else
 
{
 wait(NULL);
 printf("2");
 printf("3");
 
}
 return 0;
 
}
Ans: 1
     23
j) int main( )
 
{
 if(vfork( )==0)
 
{
 printf("1");
 _exit(0);
 
}
 else
 
{
 printf("2");
 printf("3");
 
}
 return 0;
 
}
Ans: 1
     23

k) int main( )
 
{
 pid_t c1;
 int n=10;
 c1=fork( );
 if(c1==0)
 
{
 printf(" Child
\n");
 n=20;
 printf("n=%d 
\n",n);
 
}
 else
 
{
 wait(NULL);
 printf("Parent
\n");
 printf("n=%d 
\n",n);
 
}
 return 0;
 
}
Ans: Child
     n=20
     Parent
     n=10

l) int main( )
 
{
 pid_t c1;
 int n=10;
 c1=vfork( );
 if(c1==0)
 
{
 printf(" Child
\n");
 n=20;
 printf("n=%d 
\n",n);
 _exit(0);
 
}
 else
 
{
 printf("Parent
\n");
 printf("n=%d 
\n",n);
 
}
 return 0;
 
}
Ans: Child
     n=20
     Parent
     n=20

m) int main( )
 
{
 int i=5;
 fork();
 i=i+1;
 fork();
 printf ( "% d",i);
 return 0;
 
}
Ans: 6 6 6 6

n) int main( )
 
{
 pid_t pid;
 int i=5;
 pid=vfork();
 if(pid==0)
 
{
 printf("Child: %d",i);
 _exit(0);
 
}
 else
 
{
 i=i+1;
 printf("Parent: %d",i);
 
}
 return 0;
}
Ans: Child: 5
     Parent: 6

o) int main( )
 
{
 int i=5;
 if(fork()==0)
 i=i+1;
 else
 i=i
-1;
 printf("%d",i);
 return 0;
 
}
Ans: child:i = 6
     parent: i=4
     output:
     6
     4

p) int main( )
 
{
 int i=5;
 if(vfork()==0)
 
{
 i=i+1;
 _exit(0);
 
}
 else
 i=i
-1;
 fprintf(stderr,"%d",i);
 return 0;
 
}
Ans: 4

q) int main( )
 
{
 int j,i=5;
 for(j=1;j<3;j++)
 
{
 if(fork()==0)
 
{
 i=i+1;
 break;
 
}
 else
 wait(NULL);
 
}
 printf("%d",i);
 return 0;
 
}
Ans: 6
     6

r) int main( )
 
{
 int j,i=5;
 for(j=1;j<3;j++)
 
{
 if(fork()!=0)
 
{
 i=i
-1;
 break;
 
}
 
}
 fprintf(stderr,"%d",i);
 return 0;
 
}
Ans: 4
     4

s) int main( )
 
{
 if(fork() == 0)
 if(fork())
 printf("1
\n");
 return 0;
 
}
Ans: 1


t) void fun1(){
 fork();
 fork();
 printf("1
\n");
 
}
 
 int main() {
 fun1();
 printf("1
\n");
 return 0;
 
}
Ans: 1
     1
     1
     1
     1
     1
     1
     1   (8 times)

-----------------------------------------------------------------------------------------------------------------------------

3. Write a C program that will create three child process to perform the following operations
respectively:
- First child will copy the content of file1 to file2
- Second child will display the content of file2
- Third child will display the sorted content of file2 in reverse order.
- Each child process being created will display its id and its parent process id with
appropriate message.
- The parent process will be delayed for 1 second after creation of each child process. It
will display appropriate message with its id after completion of all the child
processes.

Answer:

#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <sys/wait.h>

int main() {
    pid_t c1, c2, c3;

    // Child 1: copy file1 → file2
    if ((c1 = fork()) == 0) {
        printf("Child1: PID=%d, PPID=%d (Copying file)\n", getpid(), getppid());
        execlp("cp", "cp", "file1", "file2", NULL);
        exit(0);
    }
    sleep(1);

    // Child 2: display file2
    if ((c2 = fork()) == 0) {
        printf("Child2: PID=%d, PPID=%d (Displaying file)\n", getpid(), getppid());
        execlp("cat", "cat", "file2", NULL);
        exit(0);
    }
    sleep(1);

    // Child 3: display sorted + reverse
    if ((c3 = fork()) == 0) {
        printf("Child3: PID=%d, PPID=%d (Sorted reverse)\n", getpid(), getppid());
        execlp("sort", "sort", "-r", "file2", NULL);
        exit(0);
    }

    // Parent waits
    wait(NULL);
    wait(NULL);
    wait(NULL);

    printf("Parent finished: PID=%d\n", getpid());
    return 0;
}

-----------------------------------------------------------------------------------------------------------------------------

4. Write a C program that will create a child process to generate a Fibonacci series of specified
length and store it in an array. The parent process will wait for the child to complete its task
and then display the Fibonacci series and then display the prime Fibonacci number in the
series along with its position with appropriate message.

Answer:

#include <stdio.h>
#include <unistd.h>
#include <sys/wait.h>
#include <stdlib.h>

int isPrime(int n){
    if (n <= 1) return 0;
    for(int i=2; i*i<=n; i++)
        if(n%i==0) return 0;
    return 1;
}

int main() {
    int n, i;
    printf("Enter length: ");
    scanf("%d", &n);

    int arr[n];
    pid_t pid = fork();

    if(pid == 0){  
        arr[0] = 0; 
        arr[1] = 1;
        for(i=2;i<n;i++)
            arr[i] = arr[i-1] + arr[i-2];

        // Send values to parent using shared memory via exit? → Instead use pipe/ file.
        FILE *fp = fopen("fib.txt", "w");
        for(i=0;i<n;i++)
            fprintf(fp, "%d ", arr[i]);
        fclose(fp);

        exit(0);
    }
    else {
        wait(NULL); // wait for child
        FILE *fp = fopen("fib.txt", "r");
        for(i=0;i<n;i++)
            fscanf(fp, "%d", &arr[i]);  
        fclose(fp);

        printf("Fibonacci: ");
        for(i=0;i<n;i++)
            printf("%d ", arr[i]);

        printf("\nPrime Fibonacci numbers:\n");
        for(i=0;i<n;i++)
            if(isPrime(arr[i]))
                printf("%d at position %d\n", arr[i], i);
    }
    return 0;
}


